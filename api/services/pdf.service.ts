import puppeteer from "puppeteer";
import * as fs from "fs-extra";
import * as path from "path";
import * as os from "os";
import logger from "../config/logger";
import { SectionModel } from "../models/section.model";
import { ProjectModel } from "../models/project.model";

export interface PdfGenerationOptions {
  title?: string;
  projectName: string;
  projectDescription?: string;
  sections: SectionModel[];
  sectionDisplayOrder?: string[];
  footerText?: string;
  format?: "A4" | "Letter";
  margins?: {
    top?: string;
    right?: string;
    bottom?: string;
    left?: string;
  };
}

export class PdfService {
  /**
   * Génère un PDF à partir de sections avec Puppeteer et Tailwind CSS
   * @param options - Options de génération du PDF
   * @returns Chemin vers le fichier PDF temporaire généré
   */
  async generatePdf(options: PdfGenerationOptions): Promise<string> {
    const {
      title = "Document",
      projectName,
      projectDescription = "",
      sections,
      sectionDisplayOrder = [],
      footerText = "Generated by Idem",
      format = "A4",
      margins = {
        top: "20mm",
        right: "15mm",
        bottom: "20mm",
        left: "15mm",
      },
    } = options;

    logger.info(
      `Generating PDF for project: ${projectName} with ${sections.length} sections`
    );

    try {
      // Trier les sections selon l'ordre spécifié
      const sortedSections = this.sortSectionsByOrder(
        sections,
        sectionDisplayOrder
      );

      // Créer le contenu HTML à partir des sections
      const htmlContent = this.generateHtmlFromSections({
        title,
        projectName,
        projectDescription,
        sections: sortedSections,
        footerText,
      });

      // Lancer Puppeteer pour générer le PDF
      const browser = await puppeteer.launch({
        headless: true,
        args: ["--no-sandbox", "--disable-setuid-sandbox"],
      });

      const page = await browser.newPage();

      // Définir le contenu HTML
      await page.setContent(htmlContent, {
        waitUntil: "networkidle0",
      });

      // Créer un fichier temporaire pour le PDF
      const tempDir = os.tmpdir();
      const pdfFileName = `pdf-${Date.now()}-${Math.random()
        .toString(36)
        .substring(7)}.pdf`;
      const pdfPath = path.join(tempDir, pdfFileName);

      // Générer le PDF
      await page.pdf({
        path: pdfPath,
        format,
        printBackground: true,
        margin: margins,
        preferCSSPageSize: true,
        displayHeaderFooter: false,
        omitBackground: false,
      });

      await browser.close();

      logger.info(
        `Successfully generated PDF for project ${projectName} at ${pdfPath}`
      );
      return pdfPath;
    } catch (error) {
      logger.error(`Error generating PDF for project ${projectName}:`, error);
      throw error;
    }
  }

  /**
   * Trie les sections selon l'ordre spécifié
   * @param sections - Sections à trier
   * @param displayOrder - Ordre d'affichage souhaité
   * @returns Sections triées
   */
  private sortSectionsByOrder(
    sections: SectionModel[],
    displayOrder: string[]
  ): SectionModel[] {
    if (displayOrder.length === 0) {
      return sections;
    }

    return sections.sort(
      (a, b) => displayOrder.indexOf(a.name) - displayOrder.indexOf(b.name)
    );
  }

  /**
   * Génère le contenu HTML à partir des sections
   * @param options - Options de génération HTML
   * @returns Contenu HTML formaté
   */
  private generateHtmlFromSections(options: {
    title: string;
    projectName: string;
    projectDescription: string;
    sections: SectionModel[];
    footerText: string;
  }): string {
    const { title, projectName, projectDescription, sections, footerText } =
      options;

    let htmlContent = `
      <!DOCTYPE html>
      <html lang="fr">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${title} - ${projectName}</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <script>
          tailwind.config = {
            theme: {
              extend: {
                fontFamily: {
                  'inter': ['Inter', 'system-ui', 'sans-serif'],
                }
              }
            }
          }
        </script>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
        <style>
          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }
          
          body {
            font-family: 'Inter', system-ui, sans-serif;
          }
          
          /* Styles pour éviter la coupure des éléments */
          .section {
            page-break-inside: avoid;
            break-inside: avoid;
            display: block;
            overflow: visible;
          }
          
          .section > * {
            page-break-inside: avoid;
            break-inside: avoid;
          }
          
          .data-content {
            page-break-inside: avoid;
            break-inside: avoid;
            orphans: 3;
            widows: 3;
          }
          
          /* Forcer les sauts de page avant certains éléments si nécessaire */
          .section:not(:first-child) {
            page-break-before: auto;
            break-before: auto;
          }
          
          /* Éviter les sauts de page après les titres */
          h1, h2, h3, h4, h5, h6 {
            page-break-after: avoid;
            break-after: avoid;
            orphans: 3;
            widows: 3;
          }
          
          /* Styles spécifiques pour l'impression */
          @media print {
            .section {
              page-break-inside: avoid !important;
              break-inside: avoid !important;
            }
            
            .data-content {
              page-break-inside: avoid !important;
              break-inside: avoid !important;
            }
            
            /* Éviter les lignes orphelines et veuves */
            p, div {
              orphans: 3;
              widows: 3;
            }
          }
          
          /* Support pour les navigateurs plus anciens */
          @page {
            orphans: 3;
            widows: 3;
          }
          
          /* Supprimer les marges uniquement sur la première page */
          @page :first {
            margin: 0;
          }
        </style>
      </head>
      <body class="bg-white">
    `;

    // Ajouter chaque section
    sections.forEach((section, index) => {
      const sectionData =
        typeof section.data === "string"
          ? section.data
          : JSON.stringify(section.data, null, 2);

      // Première section (page de couverture) sans marges, autres sections avec marges
      const marginClass = index === 0 ? "" : "mb-8";

      htmlContent += `
        <div class="section ${marginClass} break-inside-avoid">
            <div class="data-content break-inside-avoid">${sectionData}</div>
        </div>
      `;
    });

    htmlContent += `
          <footer class="flex items-center justify-between px-4 py-2 mt-4 bg-gray-100 border border-gray-200 rounded-lg">
            <p class="text-sm text-gray-700">${footerText}</p>
            <div class="flex gap-x-4">
              <p class="text-sm text-gray-700">Project: <span class="font-medium">${projectName}</span></p>
              <p class="text-sm text-gray-700">|</p>
              <p class="text-sm text-gray-700"> generated on <span class="font-medium">${new Date().toLocaleDateString(
                "fr-FR",
                { year: "numeric", month: "long", day: "numeric" }
              )}</span></p>
            </div>
          </footer>
      </body>
      </html>
    `;

    return htmlContent;
  }

  /**
   * Nettoie un fichier PDF temporaire
   * @param pdfPath - Chemin vers le fichier PDF à supprimer
   */
  async cleanupTempFile(pdfPath: string): Promise<void> {
    try {
      await fs.unlink(pdfPath);
      logger.info(`Cleaned up temporary PDF file: ${pdfPath}`);
    } catch (error) {
      logger.warn(`Failed to cleanup temporary PDF file: ${pdfPath}`, error);
    }
  }
}
