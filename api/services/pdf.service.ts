import puppeteer from "puppeteer";
import * as fs from "fs-extra";
import * as path from "path";
import * as os from "os";
import logger from "../config/logger";
import { SectionModel } from "../models/section.model";
import { ProjectModel } from "../models/project.model";

export interface PdfGenerationOptions {
  title?: string;
  projectName: string;
  projectDescription?: string;
  sections: SectionModel[];
  sectionDisplayOrder?: string[];
  footerText?: string;
  format?: "A4" | "Letter";
  margins?: {
    top?: string;
    right?: string;
    bottom?: string;
    left?: string;
  };
}

export class PdfService {
  /**
   * Génère un PDF à partir de sections avec Puppeteer et Tailwind CSS
   * @param options - Options de génération du PDF
   * @returns Chemin vers le fichier PDF temporaire généré
   */
  async generatePdf(options: PdfGenerationOptions): Promise<string> {
    const {
      title = "Document",
      projectName,
      projectDescription = "",
      sections,
      sectionDisplayOrder = options.sectionDisplayOrder,
      footerText = "Generated by Idem",
      format = "A4",
      margins = {
        top: "20mm",
        right: "15mm",
        bottom: "20mm",
        left: "15mm",
      },
    } = options;

    logger.info(
      `Generating PDF for project: ${projectName} with ${sections.length} sections`
    );

    try {
      // Trier les sections selon l'ordre spécifié
      const sortedSections = sections.sort(
        (a, b) =>
          sectionDisplayOrder!.indexOf(a.name) -
          sectionDisplayOrder!.indexOf(b.name)
      );

      // Créer le contenu HTML à partir des sections
      const htmlContent = this.generateHtmlFromSections({
        title,
        projectName,
        projectDescription,
        sections: sortedSections,
        footerText,
      });

      // Lancer Puppeteer pour générer le PDF
      const browser = await puppeteer.launch({
        headless: true,
        args: ["--no-sandbox", "--disable-setuid-sandbox"],
      });

      const page = await browser.newPage();

      // Injecter le script Tailwind CSS AVANT de définir le contenu HTML
      const tailwindScriptPath = path.join(
        process.cwd(),
        "public",
        "scripts",
        "tailwind.js"
      );
      if (await fs.pathExists(tailwindScriptPath)) {
        const tailwindScript = await fs.readFile(tailwindScriptPath, "utf8");
        await page.addScriptTag({ content: tailwindScript });
        logger.info("Local Tailwind CSS script injected successfully");

        // Attendre que Tailwind soit prêt
        await page.waitForFunction('typeof window.tailwind !== "undefined"', {
          timeout: 5000,
        });
      } else {
        logger.warn("Local Tailwind script not found, falling back to CDN");
      }

      // Définir le contenu HTML APRÈS l'injection de Tailwind
      await page.setContent(htmlContent, {
        waitUntil: "networkidle0",
      });

      // Forcer Tailwind à traiter toutes les classes présentes dans le DOM
      await page.evaluate(() => {
        return new Promise((resolve) => {
          if (typeof (window as any).tailwind !== "undefined") {
            const tailwindInstance = (window as any).tailwind;

            // Méthode 1: Déclencher les événements de scan
            const events = ["DOMContentLoaded", "load"];
            events.forEach((eventType) => {
              const event = new Event(eventType);
              document.dispatchEvent(event);
            });

            // Méthode 2: Forcer le refresh si disponible
            if (tailwindInstance.refresh) {
              tailwindInstance.refresh();
            }

            // Méthode 3: Re-scanner manuellement le DOM
            if (tailwindInstance.process) {
              tailwindInstance.process(document.documentElement.outerHTML);
            }

            // Attendre un peu puis résoudre
            setTimeout(resolve, 1000);
          } else {
            resolve(undefined);
          }
        });
      });

      // Attendre supplémentaire pour s'assurer que tous les styles sont appliqués
      await new Promise((resolve) => setTimeout(resolve, 500));

      // Vérifier que les styles Tailwind sont bien appliqués
      const stylesApplied = await page.evaluate(() => {
        const testElement = document.querySelector(
          ".bg-white, .text-gray-800, .p-4, .mb-4"
        );
        if (testElement) {
          const computedStyle = window.getComputedStyle(testElement);
          return (
            computedStyle.backgroundColor !== "" ||
            computedStyle.color !== "" ||
            computedStyle.padding !== ""
          );
        }
        return false;
      });

      if (stylesApplied) {
        logger.info("Tailwind styles successfully applied to PDF content");
      } else {
        logger.warn(
          "Tailwind styles may not be fully applied - PDF styling might be incomplete"
        );
      }

      // Créer un fichier temporaire pour le PDF
      const tempDir = os.tmpdir();
      const pdfFileName = `pdf-${Date.now()}-${Math.random()
        .toString(36)
        .substring(7)}.pdf`;
      const pdfPath = path.join(tempDir, pdfFileName);

      // Générer le PDF
      await page.pdf({
        path: pdfPath,
        format,
        printBackground: true,
        margin: margins,
        preferCSSPageSize: true,
        displayHeaderFooter: false,
        omitBackground: false,
      });

      await browser.close();

      logger.info(
        `Successfully generated PDF for project ${projectName} at ${pdfPath}`
      );
      return pdfPath;
    } catch (error) {
      logger.error(`Error generating PDF for project ${projectName}:`, error);
      throw error;
    }
  }

  /**
   * Trie les sections selon l'ordre spécifié
   * @param sections - Sections à trier
   * @param displayOrder - Ordre d'affichage souhaité
   * @returns Sections triées
   */
  private sortSectionsByOrder(
    sections: SectionModel[],
    displayOrder: string[]
  ): SectionModel[] {
    if (displayOrder.length === 0) {
      return sections;
    }

    return sections.sort(
      (a, b) => displayOrder.indexOf(a.name) - displayOrder.indexOf(b.name)
    );
  }

  /**
   * Génère le contenu HTML à partir des sections
   * @param options - Options de génération HTML
   * @returns Contenu HTML formaté
   */
  private generateHtmlFromSections(options: {
    title: string;
    projectName: string;
    projectDescription: string;
    sections: SectionModel[];
    footerText: string;
  }): string {
    const { title, projectName, projectDescription, sections, footerText } =
      options;

    let htmlContent = `
      <!DOCTYPE html>
      <html lang="fr">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${title} - ${projectName}</title>
        <!-- Tailwind CSS will be injected by Puppeteer -->
        <script>
          // Configuration Tailwind - sera appliquée après injection
          function setupTailwind() {
            if (typeof window.tailwind !== 'undefined') {
              window.tailwind.config = {
                theme: {
                  extend: {
                    fontFamily: {
                      'inter': ['Inter', 'sans-serif']
                    }
                  }
                },
                corePlugins: {
                  preflight: false
                }
              };
              console.log('Tailwind config applied');
            }
          }
          
          // Essayer d'appliquer la config à différents moments
          document.addEventListener('DOMContentLoaded', setupTailwind);
          window.addEventListener('load', setupTailwind);
          // Fallback immédiat si Tailwind est déjà chargé
          if (document.readyState === 'complete') {
            setupTailwind();
          }
        </script>
        
        <style>
          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }
          
          body {
            font-family: 'Inter', system-ui, sans-serif;
          }
          
          /* Styles pour éviter la coupure des éléments */
          .section {
            page-break-inside: avoid;
            break-inside: avoid;
            display: block;
            overflow: visible;
          }
          
          .section > * {
            page-break-inside: avoid;
            break-inside: avoid;
          }
          
          .data-content {
            page-break-inside: avoid;
            break-inside: avoid;
            orphans: 3;
            widows: 3;
          }
          
          /* Forcer les sauts de page avant certains éléments si nécessaire */
          .section:not(:first-child) {
            page-break-before: auto;
            break-before: auto;
          }
          
          /* Éviter les sauts de page après les titres */
          h1, h2, h3, h4, h5, h6 {
            page-break-after: avoid;
            break-after: avoid;
            orphans: 3;
            widows: 3;
          }
          
          /* Styles spécifiques pour l'impression */
          @media print {
            .section {
              page-break-inside: avoid !important;
              break-inside: avoid !important;
            }
            
            .data-content {
              page-break-inside: avoid !important;
              break-inside: avoid !important;
            }
            
            /* Éviter les lignes orphelines et veuves */
            p, div {
              orphans: 3;
              widows: 3;
            }
          }
          
          /* Support pour les navigateurs plus anciens */
          @page {
            orphans: 3;
            widows: 3;
          }
          
          /* Supprimer les marges uniquement sur la première page */
          @page :first {
            margin: 0;
          }
        </style>
      </head>
      <body class="bg-white">
    `;

    // Ajouter chaque section
    sections.forEach((section, index) => {
      const sectionData =
        typeof section.data === "string"
          ? section.data
          : JSON.stringify(section.data, null, 2);

      // Première section (page de couverture) sans marges, autres sections avec marges
      const marginClass = index === 0 ? "" : "mb-8";

      htmlContent += `
        <div class="section ${marginClass} break-inside-avoid">
            <div class="data-content break-inside-avoid">${sectionData}</div>
        </div>
      `;
    });

    htmlContent += `
          <footer class="flex items-center justify-between px-4 py-2 mt-4 bg-gray-100 border border-gray-200 rounded-lg">
            <p class="text-sm text-gray-700">${footerText}</p>
            <div class="flex gap-x-4">
              <p class="text-sm text-gray-700">Project: <span class="font-medium">${projectName}</span></p>
              <p class="text-sm text-gray-700">|</p>
              <p class="text-sm text-gray-700"> generated on <span class="font-medium">${new Date().toLocaleDateString(
                "fr-FR",
                { year: "numeric", month: "long", day: "numeric" }
              )}</span></p>
            </div>
          </footer>
      </body>
      </html>
    `;

    return htmlContent;
  }

  /**
   * Nettoie un fichier PDF temporaire
   * @param pdfPath - Chemin vers le fichier PDF à supprimer
   */
  async cleanupTempFile(pdfPath: string): Promise<void> {
    try {
      await fs.unlink(pdfPath);
      logger.info(`Cleaned up temporary PDF file: ${pdfPath}`);
    } catch (error) {
      logger.warn(`Failed to cleanup temporary PDF file: ${pdfPath}`, error);
    }
  }
}
