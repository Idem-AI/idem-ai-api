import { IRepository } from '../repository/IRepository';
import { RepositoryFactory } from '../repository/RepositoryFactory';
import { BrandingModel } from '../models/branding.model';
import { TargetModelType } from '../enums/targetModelType.enum';
import { v4 as uuidv4 } from 'uuid';

export class BrandingService {
  private repository: IRepository<BrandingModel>;

  constructor() {
    this.repository = RepositoryFactory.getRepository<BrandingModel>(TargetModelType.BRANDING);
  }

  async generateBranding(userId: string, projectId: string, data: Omit<BrandingModel, 'id' | 'createdAt' | 'updatedAt' | 'projectId'>): Promise<BrandingModel> {
    const newBrandingData: Omit<BrandingModel, 'id' | 'createdAt' | 'updatedAt'> = {
      projectId,
      ...data,
    };
    // ID will be generated by the repository or passed if needed, repository handles createdAt/updatedAt
    return this.repository.create(newBrandingData, userId);
  }

  async getBrandingsByProjectId(userId: string, projectId: string): Promise<BrandingModel[]> {
    const allBrandings = await this.repository.findAll(userId);
    return allBrandings.filter((branding: BrandingModel) => branding.projectId === projectId);
  }

  async getBrandingById(userId: string, brandingId: string): Promise<BrandingModel | null> {
    return this.repository.findById(brandingId, userId);
  }

  async updateBranding(userId: string, brandingId: string, data: Partial<Omit<BrandingModel, 'id' | 'projectId' | 'createdAt' | 'updatedAt'>>): Promise<BrandingModel | null> {
    // Repository's update method handles updatedAt internally
    const updatePayload: Partial<Omit<BrandingModel, 'id' | 'createdAt' | 'updatedAt'>> = data;
    return this.repository.update(brandingId, updatePayload, userId);
  }

  async deleteBranding(userId: string, brandingId: string): Promise<void> {
    await this.repository.delete(brandingId, userId);
    // The repository delete returns boolean, service returns void, so no return value here.
  }
}
